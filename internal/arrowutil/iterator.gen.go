// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: iterator.gen.go.tmpl

package arrowutil

import "github.com/apache/arrow/go/arrow/array"

type Int64Iterator struct {
	Values []*array.Int64
	i      int
}

func IterateInt64s(arrs []array.Interface) Int64Iterator {
	values := make([]*array.Int64, 0, len(arrs))
	for _, arr := range arrs {
		if arr.Len() == 0 || arr.Len() == arr.NullN() {
			continue
		}
		values = append(values, arr.(*array.Int64))
	}
	if len(values) == 0 {
		return Int64Iterator{}
	}
	return Int64Iterator{Values: values}
}

// Value returns the current value in the iterator.
func (i *Int64Iterator) Value() int64 {
	vs := i.Values[0]
	return vs.Value(i.i)
}

// IsValid returns if the current value is valid.
func (i *Int64Iterator) IsValid() bool {
	vs := i.Values[0]
	return vs.IsValid(i.i)
}

// IsNull returns if the current value is null.
func (i *Int64Iterator) IsNull() bool {
	vs := i.Values[0]
	return vs.IsNull(i.i)
}

// Next will discard the current value and move to the
// next one. It will return whether another value
func (i *Int64Iterator) Next() bool {
	i.i++
	if i.i >= i.Values[0].Len() {
		i.i = 0
		i.Values = i.Values[1:]
	}
	return len(i.Values) > 0
}

// IsEmpty returns true if the iterator has no values to read.
func (i *Int64Iterator) IsEmpty() bool {
	return len(i.Values) == 0
}

type Uint64Iterator struct {
	Values []*array.Uint64
	i      int
}

func IterateUint64s(arrs []array.Interface) Uint64Iterator {
	values := make([]*array.Uint64, 0, len(arrs))
	for _, arr := range arrs {
		if arr.Len() == 0 || arr.Len() == arr.NullN() {
			continue
		}
		values = append(values, arr.(*array.Uint64))
	}
	if len(values) == 0 {
		return Uint64Iterator{}
	}
	return Uint64Iterator{Values: values}
}

// Value returns the current value in the iterator.
func (i *Uint64Iterator) Value() uint64 {
	vs := i.Values[0]
	return vs.Value(i.i)
}

// IsValid returns if the current value is valid.
func (i *Uint64Iterator) IsValid() bool {
	vs := i.Values[0]
	return vs.IsValid(i.i)
}

// IsNull returns if the current value is null.
func (i *Uint64Iterator) IsNull() bool {
	vs := i.Values[0]
	return vs.IsNull(i.i)
}

// Next will discard the current value and move to the
// next one. It will return whether another value
func (i *Uint64Iterator) Next() bool {
	i.i++
	if i.i >= i.Values[0].Len() {
		i.i = 0
		i.Values = i.Values[1:]
	}
	return len(i.Values) > 0
}

// IsEmpty returns true if the iterator has no values to read.
func (i *Uint64Iterator) IsEmpty() bool {
	return len(i.Values) == 0
}

type Float64Iterator struct {
	Values []*array.Float64
	i      int
}

func IterateFloat64s(arrs []array.Interface) Float64Iterator {
	values := make([]*array.Float64, 0, len(arrs))
	for _, arr := range arrs {
		if arr.Len() == 0 || arr.Len() == arr.NullN() {
			continue
		}
		values = append(values, arr.(*array.Float64))
	}
	if len(values) == 0 {
		return Float64Iterator{}
	}
	return Float64Iterator{Values: values}
}

// Value returns the current value in the iterator.
func (i *Float64Iterator) Value() float64 {
	vs := i.Values[0]
	return vs.Value(i.i)
}

// IsValid returns if the current value is valid.
func (i *Float64Iterator) IsValid() bool {
	vs := i.Values[0]
	return vs.IsValid(i.i)
}

// IsNull returns if the current value is null.
func (i *Float64Iterator) IsNull() bool {
	vs := i.Values[0]
	return vs.IsNull(i.i)
}

// Next will discard the current value and move to the
// next one. It will return whether another value
func (i *Float64Iterator) Next() bool {
	i.i++
	if i.i >= i.Values[0].Len() {
		i.i = 0
		i.Values = i.Values[1:]
	}
	return len(i.Values) > 0
}

// IsEmpty returns true if the iterator has no values to read.
func (i *Float64Iterator) IsEmpty() bool {
	return len(i.Values) == 0
}

type BooleanIterator struct {
	Values []*array.Boolean
	i      int
}

func IterateBooleans(arrs []array.Interface) BooleanIterator {
	values := make([]*array.Boolean, 0, len(arrs))
	for _, arr := range arrs {
		if arr.Len() == 0 || arr.Len() == arr.NullN() {
			continue
		}
		values = append(values, arr.(*array.Boolean))
	}
	if len(values) == 0 {
		return BooleanIterator{}
	}
	return BooleanIterator{Values: values}
}

// Value returns the current value in the iterator.
func (i *BooleanIterator) Value() bool {
	vs := i.Values[0]
	return vs.Value(i.i)
}

// IsValid returns if the current value is valid.
func (i *BooleanIterator) IsValid() bool {
	vs := i.Values[0]
	return vs.IsValid(i.i)
}

// IsNull returns if the current value is null.
func (i *BooleanIterator) IsNull() bool {
	vs := i.Values[0]
	return vs.IsNull(i.i)
}

// Next will discard the current value and move to the
// next one. It will return whether another value
func (i *BooleanIterator) Next() bool {
	i.i++
	if i.i >= i.Values[0].Len() {
		i.i = 0
		i.Values = i.Values[1:]
	}
	return len(i.Values) > 0
}

// IsEmpty returns true if the iterator has no values to read.
func (i *BooleanIterator) IsEmpty() bool {
	return len(i.Values) == 0
}

type StringIterator struct {
	Values []*array.Binary
	i      int
}

func IterateStrings(arrs []array.Interface) StringIterator {
	values := make([]*array.Binary, 0, len(arrs))
	for _, arr := range arrs {
		if arr.Len() == 0 || arr.Len() == arr.NullN() {
			continue
		}
		values = append(values, arr.(*array.Binary))
	}
	if len(values) == 0 {
		return StringIterator{}
	}
	return StringIterator{Values: values}
}

// Value returns the current value in the iterator.
func (i *StringIterator) ValueString() string {
	vs := i.Values[0]
	return vs.ValueString(i.i)
}

// IsValid returns if the current value is valid.
func (i *StringIterator) IsValid() bool {
	vs := i.Values[0]
	return vs.IsValid(i.i)
}

// IsNull returns if the current value is null.
func (i *StringIterator) IsNull() bool {
	vs := i.Values[0]
	return vs.IsNull(i.i)
}

// Next will discard the current value and move to the
// next one. It will return whether another value
func (i *StringIterator) Next() bool {
	i.i++
	if i.i >= i.Values[0].Len() {
		i.i = 0
		i.Values = i.Values[1:]
	}
	return len(i.Values) > 0
}

// IsEmpty returns true if the iterator has no values to read.
func (i *StringIterator) IsEmpty() bool {
	return len(i.Values) == 0
}

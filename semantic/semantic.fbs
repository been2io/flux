namespace fbsemantic;

union MonoType {
  Basic,
  Var,
  Arr,
  Row,
  Fun,
}

enum Type : ubyte {
  Bool,
  Int,
  Uint,
  Float,
  String,
  Duration,
  Time,
  Regexp,
}

table Var {
  i:ulong;
}

table Basic {
  t:Type;
}

table Arr {
  t:MonoType;
}

table Row {
  props:[Prop];
  extends:Var;
}

table Fun {
  args:[Argument];
  retn:MonoType;
}

table Argument {
  name:string;
  t:MonoType;
  pipe:bool;
  optional:bool;
}

table Prop {
  k:string;
  v:MonoType;
}

table PolyType {
  vars:[Var];
  cons:[Constraint];
  expr:MonoType;
}

enum Kind : ubyte {
  Addable,
  Subtractable,
  Divisible,
  Comparable,
  Equatable,
  Nullable,
}

table Constraint {
  tvar:Var;
  kind:Kind;
}

union Statement {
  OptionStatement,
  BuiltinStatement,
  TestStatement,
  ExpressionStatement,
  ReturnStatement,
}

union Assignment {
  MemberAssignment,
  NativeVariableAssignment,
}

union Expression  {
  StringExpression,
  ArrayExpression,
  FunctionExpression,
  BinaryExpression,
  CallExpression,
  ConditionalExpression,
  IdentifierExpression,
  LogicalExpression,
  MemberExpression,
  IndexExpression,
  ObjectExpression,
  UnaryExpression,
  BooleanLiteral,
  DateTimeLiteral,
  DurationLiteral,
  FloatLiteral,
  IntegerLiteral,
  StringLiteral,
  RegexpLiteral,
  UnsignedIntegerLiteral,
}

union PropertyKey {
  Identifier,
  StringLiteral,
}

table Package {
  loc:SourceLocation;
  package:string;
  files:[File];
}

table File {
  loc:SourceLocation;
  package:PackageClause;
  imports:[ImportDeclaration];
  body:[WrappedStatement];
}

table PackageClause {
  loc:SourceLocation;
  name:Identifier;
}

table ImportDeclaration {
  loc:SourceLocation;
  as:Identifier;
  path:StringLiteral;
}

table Block {
  loc:SourceLocation;
  body:[WrappedStatement];
}

table SourceLocation {
  file:string;
  start:Position;
  end:Position;
  source:string;
}

struct Position {
  line:int;
  column:int;
}

// Statements

// Unions cannot be vector elements,
// so wrap the union in a table.
table WrappedStatement {
  statement:Statement;
}

table OptionStatement {
  loc:SourceLocation;
  assignment:Assignment;
}

table BuiltinStatement {
  loc:SourceLocation;
  id:Identifier;
}

table TestStatement {
  loc:SourceLocation;
  assignment:NativeVariableAssignment;
}

table ExpressionStatement {
  loc:SourceLocation;
  expression:Expression;
}

table ReturnStatement {
  loc:SourceLocation;
  argument:Expression;
}

table NativeVariableAssignment {
  loc:SourceLocation;
  identifier:Identifier;
  init_:Expression;
  typ:PolyType;
}

table MemberAssignment {
  loc:SourceLocation;
  member:MemberExpression;
  init_:Expression;
}

// Expressions

// Unions cannot be vector elements,
// so wrap the union in a table.
table WrappedExpression {
  expression:Expression;
}

table StringExpression {
  loc:SourceLocation;
  parts:[StringExpressionPart];
  typ:MonoType;
}

table StringExpressionPart {
  loc:SourceLocation;
  // Following two fields are mutually exclusive:
  text_value:string;// for TextPart
  interpolated_expression:Expression;// for InterpolatedPart
}

table ArrayExpression {
  loc:SourceLocation;
  elements:[WrappedExpression];
  typ:MonoType;
}

table FunctionExpression {
  loc:SourceLocation;
  defaults:ObjectExpression;
  Block:FunctionBlock;
  typ:MonoType;
}

table FunctionBlock {
  loc:SourceLocation;
  parameters:FunctionParameters;
  body:Block;
}

table FunctionParameters {
  loc:SourceLocation;
  list:[FunctionParameter];
  pipe:Identifier;
}

table FunctionParameter {
  loc:SourceLocation;
  key:Identifier;
}

enum Operator : byte {
  MultiplicationOperator,
  DivisionOperator,
  ModuloOperator,
  PowerOperator,
  AdditionOperator,
  SubtractionOperator,
  LessThanEqualOperator,
  LessThanOperator,
  GreaterThanEqualOperator,
  GreaterThanOperator,
  StartsWithOperator,
  InOperator,
  NotOperator,
  ExistsOperator,
  NotEmptyOperator,
  EmptyOperator,
  EqualOperator,
  NotEqualOperator,
  RegexpMatchOperator,
  NotRegexpMatchOperator,
  InvalidOperator,
}

enum LogicalOperator : byte {
  AndOperator,
  OrOperator,
}

table BinaryExpression {
  loc:SourceLocation;
  operator:Operator;
  left: Expression;
  right: Expression;
  typ:MonoType;
}

table CallExpression {
  loc:SourceLocation;
  callee:Expression;
  arguments:ObjectExpression;
  pipe:Expression;
  typ:MonoType;
}

table ConditionalExpression {
  loc:SourceLocation;
  test:Expression;
  alternate:Expression;
  consequent:Expression;
  typ:MonoType;
}

table LogicalExpression {
  loc:SourceLocation;
  operator:LogicalOperator;
  left:Expression;
  right:Expression;
  typ:MonoType;
}

table MemberExpression {
  loc:SourceLocation;
  object:Expression;
  property:string;
  typ:MonoType;
}

table IndexExpression {
  loc:SourceLocation;
  array:Expression;
  index:Expression;
  typ:MonoType;
}

table ObjectExpression {
  loc:SourceLocation;
  with:IdentifierExpression;
  properties:[Property];
  typ:MonoType;
}

table UnaryExpression {
  loc:SourceLocation;
  operator:Operator;
  argument:Expression;
  typ:MonoType;
}

table Property {
  loc:SourceLocation;
  key:PropertyKey;
  value:Expression;
}

table IdentifierExpression {
  loc:SourceLocation;
  name:string;
  typ:MonoType;
}

table Identifier {
  loc:SourceLocation;
  name:string;
}

table BooleanLiteral {
  loc:SourceLocation;
  value:bool;
  typ:MonoType;
}

table DateTimeLiteral {
  loc:SourceLocation;
  value:Time;
  typ:MonoType;
}

table Time {
    secs:int64;
    nsecs:uint32;
    offset:int32;
}

table DurationLiteral {
  loc:SourceLocation;
  value:[Duration];
  typ:MonoType;
}

enum TimeUnit : byte {
  y,
  mo,
  w,
  d,
  h,
  m,
  s,
  ms,
  us,
  ns,
}

table Duration {
  magnitude:int64;
  unit:TimeUnit;
}

table IntegerLiteral {
  loc:SourceLocation;
  value:long;
  typ:MonoType;
}

table FloatLiteral {
  loc:SourceLocation;
  value:double;
  typ:MonoType;
}

table RegexpLiteral {
  loc:SourceLocation;
  value:string;
  typ:MonoType;
}

table StringLiteral {
  loc:SourceLocation;
  value:string;
  typ:MonoType;
}

table UnsignedIntegerLiteral {
  loc:SourceLocation;
  value:ulong;
  typ:MonoType;
}

root_type Package;
